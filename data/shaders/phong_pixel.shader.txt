
#if defined VERTEX_SHADER

uniform mat4 u_camera_to_clip_projection;
uniform mat4x3 u_world_to_camera_transform;
uniform mat4x3 u_object_to_world_transform;

#if defined MAX_BONE_COUNT
uniform mat4x3 u_bone_transforms[MAX_BONE_COUNT];

in vec4 a_bone_indices; // somehow it doesn't like integer uvec4 -.-, why gl why?
in vec4 a_bone_weights;
#endif

in vec3 a_position;
in vec3 a_normal;

#if defined MAX_LIGHT_COUNT
uniform vec3 u_camera_world_position;
uniform vec3 u_light_world_positions[MAX_LIGHT_COUNT];
uniform uint u_light_count;

out vec3 camera_direction;
out vec3 light_directions[MAX_LIGHT_COUNT];
//out vec3 light_world_distances[MAX_LIGHT_COUNT];
#endif

#if defined WITH_NORMAL_MAP
in vec3 a_tangent;

#  if defined TANGENT_TRANSFORM_PER_FRAGMENT
out vec3 world_tangent;
#  endif

#endif

#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
in vec2 a_uv;

out vec2 uv;
#endif

out vec3 world_position;
out vec3 world_normal;

void main() {

#if defined MAX_BONE_COUNT

	world_position = vec3(0.0);
	world_normal   = vec3(0.0);

#  if defined WITH_NORMAL_MAP
	vec3 tangent  = vec3(0.0)
#  endif
	
	for (int i = 0; i < 4; ++i)
	{
		uint index = uint(a_bone_indices[i]);
		world_position += (u_bone_transforms[index] * vec4(a_position, 1.0)) * a_bone_weights[i];
		world_normal   += (u_bone_transforms[index] * vec4(a_normal, 0.0))   * a_bone_weights[i];

#  if defined WITH_NORMAL_MAP
		tangent  += (u_bone_transforms[index] * vec4(a_tangent, 0.0))  * a_bone_weights[i];
#  endif
	
	}

#else

	world_position = a_position;
	world_normal   = a_normal;

#  if defined WITH_NORMAL_MAP
	vec3 tangent  = a_tangent;
#  endif

#endif

	world_position = u_object_to_world_transform * vec4(world_position, 1.0);
	world_normal   = u_object_to_world_transform * vec4(world_normal, 0.0);

#if defined WITH_NORMAL_MAP
	tangent = u_object_to_world_transform * vec4(tangent, 0.0);

#  if !defined TANGENT_TRANSFORM_PER_FRAGMENT
	mat3 world_to_tangent_transform = transpose(mat3(
        normalize(tangent),
        normalize(cross(world_normal, tangent)),
        normalize(world_normal)
    ));
#else
	world_tangent = tangent;
#  endif

#endif

#if defined MAX_LIGHT_COUNT
	for (uint light_index = uint(0); light_index < u_light_count; ++light_index)
	{
		vec3 light_world_distance = u_light_world_positions[light_index] - world_position;
		//light_world_distances[light_index] = light_world_distance;

#  if defined TANGENT_TRANSFORM_PER_FRAGMENT
		light_directions[light_index] = normalize(light_world_distance);
#  else
		light_directions[light_index] = normalize(world_to_tangent_transform * light_world_distance);
#endif
	}

#  if defined TANGENT_TRANSFORM_PER_FRAGMENT
	camera_direction = normalize(u_camera_world_position - world_position);
#  else
	camera_direction = normalize(world_to_tangent_transform * (u_camera_world_position - world_position));
#  endif

#endif

#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
	uv = a_uv;
#endif

	gl_Position = u_camera_to_clip_projection * vec4(u_world_to_camera_transform * vec4(world_position, 1.0), 1.0);
}

#endif

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX//

#if defined FRAGMENT_SHADER

uniform vec4 u_ambient_color;

in vec3 world_position;
in vec3 world_normal;

#if defined MAX_LIGHT_COUNT
uniform vec3 u_light_world_positions[MAX_LIGHT_COUNT];
uniform vec4 u_light_diffuse_colors[MAX_LIGHT_COUNT];
uniform vec4 u_light_specular_colors[MAX_LIGHT_COUNT];
uniform uint u_light_count;

in vec3 camera_direction;
in vec3 light_directions[MAX_LIGHT_COUNT];
//in vec3 light_world_distances[MAX_LIGHT_COUNT];
#endif

#if defined WITH_DIFFUSE_TEXTURE
uniform sampler2D u_diffuse_texture;
#endif

#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
in vec2 uv;
#endif

#if defined WITH_DIFFUSE_COLOR
uniform vec4 u_diffuse_color;
#endif

#if defined WITH_NORMAL_MAP
uniform sampler2D u_normal_map;

#  if defined TANGENT_TRANSFORM_PER_FRAGMENT
in vec3 world_tangent;
#  endif

#endif

out vec4 out_color;

void main() {

	vec4 diffuse_color  = u_ambient_color;
	vec4 specular_color = vec4(0);

#if defined MAX_LIGHT_COUNT

#  if defined WITH_NORMAL_MAP
	vec3 normal = normalize(texture(u_normal_map, uv).xyz * 2  - 1);

#    if defined TANGENT_TRANSFORM_PER_FRAGMENT
	mat3 world_to_tangent_transform = transpose(mat3(
        normalize(world_tangent),
        normalize(cross(world_normal, world_tangent)),
        normalize(world_normal)
    ));

	vec3 camera_dir = normalize(world_to_tangent_transform * camera_direction);
#    endif

#  else

	vec3 normal = normalize(world_normal);

#  endif

#  if !defined TANGENT_TRANSFORM_PER_FRAGMENT
	vec3 camera_dir = normalize(camera_direction);
#  endif

	for (uint light_index = uint(0); light_index < u_light_count; ++light_index)
	{		
		vec3 light_distance = u_light_world_positions[light_index] - world_position;
		//vec3 light_distance = light_world_distances[light_index];

#  if defined TANGENT_TRANSFORM_PER_FRAGMENT
		vec3 light_dir = normalize(world_to_tangent_transform * light_distance);
#  else
		vec3 light_dir = normalize(light_directions[light_index]);
#  endif

		vec3 r = (normal * (2.0 * dot(light_dir, normal)) - light_dir);

		float attenuation = 1.0 / (1 + 0.25 * dot(light_distance, light_distance));

		float intensity = max(0.0, dot(normal, light_dir));

		diffuse_color  += u_light_diffuse_colors[light_index]  * intensity;	
		specular_color += u_light_specular_colors[light_index] * pow(max(0.0, dot(camera_dir, r)), 15) * (1.0 - step(intensity, 0.0));
	}

#else

	diffuse_color = vec4(1);

#endif

#if defined WITH_DIFFUSE_TEXTURE
	diffuse_color *= texture(u_diffuse_texture, uv); 
#endif

#if defined WITH_DIFFUSE_COLOR
	diffuse_color *= u_diffuse_color;
#endif

	out_color = diffuse_color + specular_color;

	// for debuging
	//out_color = vec4(normal * 0.5 + 0.5, 1.0);
	//out_color = vec4(normalize(light_directions[0]) * 0.5 + 0.5, 1.0);
	//out_color = vec4(normalize(camera_direction) * 0.5 + 0.5, 1.0);
}

#endif

#if defined VERTEX_SHADER

uniform mat4 u_camera_to_clip_projection;
uniform mat4x3 u_world_to_camera_transform;
uniform mat4x3 u_object_to_world_transform;

#if defined MAX_BONE_COUNT
uniform mat4x3 u_bone_transforms[MAX_BONE_COUNT];

in vec4 a_bone_indices; // somehow it doesn't like integer uvec4 -.-, why gl why?
in vec4 a_bone_weights;
#endif

in vec3 a_position;
in vec3 a_normal;

#if defined WITH_NORMAL_MAP
in vec3 a_tangent;

out vec3 world_tangent;
#endif

#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
in vec2 a_uv;

out vec2 uv;
#endif

smooth out vec3 world_position;
smooth out vec3 world_normal;

void main() {

#if defined MAX_BONE_COUNT

	world_position = vec3(0.0);
	world_normal   = vec3(0.0);

#  if defined WITH_NORMAL_MAP
	world_tangent  = vec3(0.0)
#  endif
	
	for (int i = 0; i < 4; ++i)
	{
		uint index = uint(a_bone_indices[i]);
		world_position += (u_bone_transforms[index] * vec4(a_position, 1.0)) * a_bone_weights[i];
		world_normal   += (u_bone_transforms[index] * vec4(a_normal, 0.0))   * a_bone_weights[i];

#  if defined WITH_NORMAL_MAP
		world_tangent  += (u_bone_transforms[index] * vec4(a_tangent, 0.0))  * a_bone_weights[i];
#  endif
	
	}

#else

	world_position = a_position;
	world_normal   = a_normal;

#  if defined WITH_NORMAL_MAP
	world_tangent  = a_tangent;
#  endif

#endif

	world_position = u_object_to_world_transform * vec4(world_position, 1.0);
	world_normal   = u_object_to_world_transform * vec4(world_normal, 0.0);

#if defined WITH_NORMAL_MAP
	world_tangent  = u_object_to_world_transform * vec4(world_tangent, 0.0);
#endif
	
#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
	uv = a_uv;
#endif

	gl_Position = u_camera_to_clip_projection * vec4(u_world_to_camera_transform * vec4(world_position, 1.0), 1.0);
}

#endif

//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX//

#if defined FRAGMENT_SHADER

uniform vec3 u_camera_world_position;
uniform vec4 u_ambient_color;

smooth in vec3 world_position;
smooth in vec3 world_normal;

#if defined MAX_LIGHT_COUNT
uniform vec3 u_light_world_positions[MAX_LIGHT_COUNT];
uniform vec4 u_light_diffuse_colors[MAX_LIGHT_COUNT];
uniform vec4 u_light_specular_colors[MAX_LIGHT_COUNT];
uniform uint u_light_count;
#endif

#if defined WITH_DIFFUSE_TEXTURE
uniform sampler2D u_diffuse_texture;
#endif

#if (defined WITH_DIFFUSE_TEXTURE) || (defined WITH_NORMAL_MAP)
in vec2 uv;
#endif

#if defined WITH_DIFFUSE_COLOR
uniform vec4 u_diffuse_color;
#endif

#if defined WITH_NORMAL_MAP
uniform sampler2D u_normal_map;

smooth in vec3 world_tangent;
#endif

out vec4 out_color;

void main() {

	vec4 diffuse_color  = u_ambient_color;
	vec4 specular_color = vec4(0);

#if defined MAX_LIGHT_COUNT

#  if defined WITH_NORMAL_MAP
		vec3 normal = normalize((texture(u_normal_map, uv).xyz - vec3(0.5)) * 2);
#  else
		vec3 normal = normalize(world_normal);
#  endif

	vec3 camera_dir = normalize(u_camera_world_position - world_position);

	for (uint light_index = uint(0); light_index < u_light_count; ++light_index)
	{
		vec3 light_distance = u_light_world_positions[light_index] - world_position;
	
		vec3 light_dir = normalize(light_distance);
		vec3 r = (normal * (2.0 * dot(light_dir, normal)) - light_dir);

		float attenuation = 1.0 / (1 + 0.25 * dot(light_distance, light_distance));

		float intensity = max(0.0, dot(normal, light_dir));

		diffuse_color  += u_light_diffuse_colors[light_index]  * intensity;	
		specular_color += u_light_specular_colors[light_index] * pow(max(0.0, dot(camera_dir, r)), 15) * (1.0 - step(intensity, 0.0));
	}

#else

	diffuse_color = vec4(1);

#endif

#if 0
	float gamma = 1.0/2.2;
	float ilumination = pow((diffuse + specular) * attenuation, gamma) + 0.3;
//#else
	float ilumination = (diffuse + specular) * attenuation;
#endif

	//color = vec4(vec3(ilumination), 1.0f);

#if defined WITH_DIFFUSE_TEXTURE
	diffuse_color *= texture(u_diffuse_texture, uv); 
#endif

#if defined WITH_DIFFUSE_COLOR
	diffuse_color *= u_diffuse_color;
#endif

	//color = vec4(specular, specular, specular, 1.0f);
	//color = vec4(ilumination, ilumination, ilumination, 1.0f);

	out_color = diffuse_color + specular_color;

#if defined DEBUG_NORMALS
	out_color = vec4(normal * 0.5 + vec3(0.5), 1.0);
#endif
}

#endif